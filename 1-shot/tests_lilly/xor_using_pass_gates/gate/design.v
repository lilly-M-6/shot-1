/* Generated by Yosys 0.9 (git sha1 1979e0b) */

module circuit(clk, input1_0, input1_1, input2_0, input2_1, r0, r1, r2, xor_output_0, xor_output_1);
  input clk;
  input input1_0;
  input input1_1;
  input input2_0;
  input input2_1;
  input r0;
  input r1;
  input r2;
  output xor_output_0;
  wire xor_output_0_w;
  output xor_output_1;
  wire xor_output_1_w;
  DFF _0_ (
    .C(clk),
    .D(xor_output_1_w),
    .Q(xor_output_1)
  );
  DFF _1_ (
    .C(clk),
    .D(xor_output_0_w),
    .Q(xor_output_0)
  );
  xor_using_pass_gates_masked uut (
    .input1_0(input1_0),
    .input1_1(input1_1),
    .input2_0(input2_0),
    .input2_1(input2_1),
    .r0(r0),
    .r1(r1),
    .r2(r2),
    .xor_output_0(xor_output_0_w),
    .xor_output_1(xor_output_1_w)
  );
endmodule

module xor_using_pass_gates_masked(input1_0, input1_1, input2_0, input2_1, r0, r1, r2, xor_output_0, xor_output_1);
  wire _00_;
  wire _01_;
  wire _02_;
  wire _03_;
  wire _04_;
  wire _05_;
  wire _06_;
  wire _07_;
  wire and_0;
  wire and_1;
  wire and_p00;
  wire and_p01;
  wire and_p10;
  wire and_p11;
  input input1_0;
  input input1_1;
  input input2_0;
  input input2_1;
  wire not_input1_0;
  wire not_input1_1;
  wire not_input2_0;
  wire not_input2_1;
  wire pg1_0;
  wire pg1_1;
  wire pg1_p00;
  wire pg1_p01;
  wire pg1_p10;
  wire pg1_p11;
  wire pg2_0;
  wire pg2_1;
  wire pg2_p00;
  wire pg2_p01;
  wire pg2_p10;
  wire pg2_p11;
  input r0;
  input r1;
  input r2;
  output xor_output_0;
  output xor_output_1;
  assign not_input2_0 = ~input2_0;
  assign not_input2_1 = ~input2_1;
  assign not_input1_0 = ~input1_0;
  assign not_input1_1 = ~input1_1;
  assign _03_ = pg2_p11 ^ pg2_p10;
  assign pg2_1 = _03_ ^ r1;
  assign and_p00 = pg1_0 & pg2_0;
  assign and_p01 = pg1_0 & pg2_1;
  assign and_p10 = pg1_1 & pg2_0;
  assign and_p11 = pg1_1 & pg2_1;
  assign _04_ = and_p00 ^ and_p01;
  assign and_0 = _04_ ^ r2;
  assign _05_ = and_p11 ^ and_p10;
  assign and_1 = _05_ ^ r2;
  assign _06_ = pg1_0 ^ pg2_0;
  assign xor_output_0 = _06_ ^ and_0;
  assign _07_ = pg1_1 ^ pg2_1;
  assign xor_output_1 = _07_ ^ and_1;
  assign pg1_p00 = input1_0 & not_input2_0;
  assign pg1_p01 = input1_0 & not_input2_1;
  assign pg1_p10 = input1_1 & not_input2_0;
  assign pg1_p11 = input1_1 & not_input2_1;
  assign _00_ = pg1_p00 ^ pg1_p01;
  assign pg1_0 = _00_ ^ r0;
  assign _01_ = pg1_p11 ^ pg1_p10;
  assign pg1_1 = _01_ ^ r0;
  assign pg2_p00 = not_input1_0 & input2_0;
  assign pg2_p01 = not_input1_0 & input2_1;
  assign pg2_p10 = not_input1_1 & input2_0;
  assign pg2_p11 = not_input1_1 & input2_1;
  assign _02_ = pg2_p00 ^ pg2_p01;
  assign pg2_0 = _02_ ^ r1;
endmodule
